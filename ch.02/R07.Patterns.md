# Common patterns
Useful conventions

## Multi-line
The following works fine, because the `div` is on the same line as the return.

```html
return <div />
```

The following not.

```html
return
    <div />>
```

Because you would have the following when the JSX transpliled to JavaScript. 

```javascript
return;
React.createElement("div", null);
```

That is why you have to wrap the statement in parentheses. 

```javascript
return (
    <div />
)
```

JSX
```javascript
class BadMultiline extends React.Component {
    render () {
        return
            <div />
    }
}
```
> ./node_modules/.bin/babel ch.02/11.bad.multiline.jsx.js --presets react -o ch.02/12.bad.multiline.javascript.js

JavaScript
```javascript
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BadMultiline = function (_React$Component) {
    _inherits(BadMultiline, _React$Component);

    function BadMultiline() {
        _classCallCheck(this, BadMultiline);

        return _possibleConstructorReturn(this, (BadMultiline.__proto__ || Object.getPrototypeOf(BadMultiline)).apply(this, arguments));
    }

    _createClass(BadMultiline, [{
        key: "render",
        value: function render() {
            return; // ***
            React.createElement("div", null);
        }
    }]);

    return BadMultiline;
}(React.Component);
```

## Multi-properties
A common problem in writing JSX comes when an element has multiple attribute. Writing all solutions in one line, would lead
to very long lines. Solution, is to write each attribute on a new line. 

```javascript
<button 
    foo="bar",
    veryLongPropertyName="baz",
    onSomething={this.handleSomething}
/>
```

